<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Research Mode - Crossword Clues</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    h1 {
      margin: 0;
    }
    .nav-links {
      display: flex;
      gap: 16px;
    }
    .nav-link {
      color: #007bff;
      text-decoration: none;
      font-weight: 500;
    }
    .nav-link:hover {
      text-decoration: underline;
    }
    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }
    .clues-container {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .clues-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #eee;
    }
    .clues-header h2 {
      margin: 0;
    }
    .clue-count {
      color: #666;
      font-size: 14px;
    }
    .clue-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .clue-item {
      padding: 12px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    .clue-item:last-child {
      border-bottom: none;
    }
    .clue-item.complete {
      opacity: 0.6;
    }
    .clue-item.complete .clue-icon {
      display: none;
    }
    .clue-meta {
      font-size: 12px;
      color: #999;
      margin-bottom: 4px;
    }
    .clue-text-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }
    .clue-text {
      color: #333;
    }
    .clue-icon {
      opacity: 0;
      transition: opacity 0.2s;
      color: #999;
      text-decoration: none;
      font-size: 12px;
      cursor: pointer;
      padding: 2px;
    }
    .clue-icon:hover {
      color: #007bff;
    }
    .clue-item:hover .clue-icon {
      opacity: 1;
    }
    .clue-icon.ignore:hover {
      color: #dc3545;
    }
    .clue-answer-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .letter-inputs {
      display: flex;
      gap: 2px;
    }
    .letter-input {
      width: 24px;
      height: 28px;
      padding: 0;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-family: monospace;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      text-transform: uppercase;
      background: white;
    }
    .letter-input:focus {
      outline: none;
      border-color: #007bff;
      background: #e3f2fd;
    }
    .letter-input.from-pattern {
      color: #2e7d32;
      background: #e8f5e9;
    }
    .letter-input.user-entered {
      color: #666;
    }
    .letter-input.empty {
      background: #fafafa;
    }
    .save-status {
      font-size: 12px;
      color: #666;
    }
    .save-status.saving {
      color: #ff9800;
    }
    .save-status.saved {
      color: #4caf50;
    }
    .save-status.error {
      color: #f44336;
    }
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    .toggle-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
    }
    .toggle-label {
      font-size: 14px;
      color: #666;
      cursor: pointer;
    }
    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: #ccc;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .toggle-switch.active {
      background: #007bff;
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s;
    }
    .toggle-switch.active::after {
      transform: translateX(20px);
    }
    .error {
      background: #fee;
      color: #c00;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Research Mode</h1>
    <div class="nav-links">
      <a href="/" class="nav-link">Clues</a>
      <a href="/quiz.html" class="nav-link">Quiz</a>
      <a href="/performance.html" class="nav-link">Performance</a>
    </div>
  </header>
  <p class="subtitle">Find and enter correct answers for incomplete clues</p>

  <div class="toggle-container">
    <span class="toggle-label" onclick="toggleShowAll()">Show all clues</span>
    <div class="toggle-switch" id="showAllToggle" onclick="toggleShowAll()"></div>
  </div>

  <div id="clues" class="clues-container">
    <div class="loading">Loading incomplete clues...</div>
  </div>

  <script>
    const API_BASE = '';
    let showAll = false;

    function toggleShowAll() {
      showAll = !showAll;
      document.getElementById('showAllToggle').classList.toggle('active', showAll);
      loadClues();
    }

    async function loadClues() {
      const container = document.getElementById('clues');

      try {
        const url = showAll ? `${API_BASE}/api/incomplete?all=true` : `${API_BASE}/api/incomplete`;
        const res = await fetch(url);
        const data = await res.json();

        if (!data.clues || data.clues.length === 0) {
          container.innerHTML = '<div class="empty-state">No incomplete clues found. Great job!</div>';
          return;
        }

        const headerText = showAll ? 'All Clues' : 'Incomplete Clues';
        const countText = showAll ? `${data.total} clues` : `${data.total} clues need answers`;
        container.innerHTML = `
          <div class="clues-header">
            <h2>${headerText}</h2>
            <span class="clue-count">${countText}</span>
          </div>
          <ul class="clue-list">
            ${data.clues.map(clue => renderClue(clue)).join('')}
          </ul>
        `;

        setupInputListeners();
      } catch (err) {
        container.innerHTML = `<div class="error">Failed to load clues: ${err.message}</div>`;
      }
    }

    function renderClue(clue) {
      const clueId = `${clue.direction}-${clue.number}`;
      const pattern = clue.pattern || '';
      const answer = clue.answer || '';
      const isComplete = answer.length === pattern.length && answer.length > 0;

      // Build letter inputs
      let letterInputs = '';
      for (let i = 0; i < pattern.length; i++) {
        const patternChar = pattern[i];
        const answerChar = answer[i] || '';
        const displayChar = answerChar || (patternChar !== '_' ? patternChar : '');

        let className = 'letter-input';
        if (displayChar) {
          if (patternChar !== '_' && displayChar === patternChar) {
            className += ' from-pattern';
          } else {
            className += ' user-entered';
          }
        } else {
          className += ' empty';
        }

        letterInputs += `<input
          type="text"
          class="${className}"
          value="${escapeHtml(displayChar)}"
          maxlength="1"
          data-index="${i}"
        >`;
      }

      // Build Google search URL
      const searchQuery = encodeURIComponent(`${clue.text} crossword clue`);
      const searchUrl = `https://www.google.com/search?q=${searchQuery}`;

      return `
        <li class="clue-item${isComplete ? ' complete' : ''}" data-clue-id="${clueId}" data-puzzle-date="${clue.puzzleDate}">
          <div class="clue-meta">${formatDate(clue.puzzleDate)} - ${clue.direction.toUpperCase()} ${clue.number}</div>
          <div class="clue-text-row">
            <span class="clue-text">${escapeHtml(clue.text)} (${pattern.length})</span>
            <a href="${searchUrl}" target="_blank" rel="noopener" class="clue-icon search" title="Search for clue">&#x1F50D;</a>
            <span class="clue-icon ignore" title="Ignore this clue" onclick="ignoreClue('${clueId}', '${clue.puzzleDate}')">&#x1F6AB;</span>
          </div>
          <div class="clue-answer-row">
            <div class="letter-inputs" data-clue-id="${clueId}" data-puzzle-date="${clue.puzzleDate}" data-pattern="${escapeHtml(pattern)}">
              ${letterInputs}
            </div>
            <span class="save-status" data-status-for="${clueId}"></span>
          </div>
        </li>
      `;
    }

    function setupInputListeners() {
      document.querySelectorAll('.letter-inputs').forEach(letterContainer => {
        let saveTimeout;
        const clueId = letterContainer.dataset.clueId;
        const puzzleDate = letterContainer.dataset.puzzleDate;
        const pattern = letterContainer.dataset.pattern;

        letterContainer.querySelectorAll('.letter-input').forEach((input, idx) => {
          input.addEventListener('input', (e) => {
            const val = e.target.value.toUpperCase();
            e.target.value = val;

            // Update styling
            updateLetterStyle(input, idx, pattern);

            // Move to next input if a letter was entered
            if (val && idx < pattern.length - 1) {
              const nextInput = letterContainer.querySelectorAll('.letter-input')[idx + 1];
              if (nextInput) nextInput.focus();
            }

            // Schedule save
            clearTimeout(saveTimeout);
            const statusEl = document.querySelector(`[data-status-for="${clueId}"]`);
            statusEl.textContent = '';
            statusEl.className = 'save-status';
            saveTimeout = setTimeout(() => saveAnswer(letterContainer), 500);
          });

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace' && !e.target.value && idx > 0) {
              const prevInput = letterContainer.querySelectorAll('.letter-input')[idx - 1];
              if (prevInput) {
                prevInput.focus();
                prevInput.select();
              }
            } else if (e.key === 'ArrowLeft' && idx > 0) {
              const prevInput = letterContainer.querySelectorAll('.letter-input')[idx - 1];
              if (prevInput) prevInput.focus();
            } else if (e.key === 'ArrowRight' && idx < pattern.length - 1) {
              const nextInput = letterContainer.querySelectorAll('.letter-input')[idx + 1];
              if (nextInput) nextInput.focus();
            }
          });

          input.addEventListener('focus', () => input.select());

          // Handle paste to distribute characters across inputs
          input.addEventListener('paste', (e) => {
            e.preventDefault();
            const pastedText = (e.clipboardData || window.clipboardData).getData('text').toUpperCase().replace(/[^A-Z]/g, '');
            if (!pastedText) return;

            const inputs = letterContainer.querySelectorAll('.letter-input');
            let pasteIdx = 0;

            // Fill inputs starting from current position
            for (let i = idx; i < inputs.length && pasteIdx < pastedText.length; i++) {
              inputs[i].value = pastedText[pasteIdx];
              updateLetterStyle(inputs[i], i, pattern);
              pasteIdx++;
            }

            // Focus the next empty input or the last filled one
            const nextEmptyIdx = Math.min(idx + pastedText.length, inputs.length - 1);
            inputs[nextEmptyIdx].focus();

            // Schedule save
            clearTimeout(saveTimeout);
            const statusEl = document.querySelector(`[data-status-for="${clueId}"]`);
            statusEl.textContent = '';
            statusEl.className = 'save-status';
            saveTimeout = setTimeout(() => saveAnswer(letterContainer), 500);
          });

          // Remove completed clue when focus leaves
          input.addEventListener('blur', () => {
            setTimeout(() => {
              // Check if focus moved outside this clue's inputs
              const activeElement = document.activeElement;
              const stillInSameClue = letterContainer.contains(activeElement);

              if (!stillInSameClue) {
                // Check if clue is complete
                const inputs = letterContainer.querySelectorAll('.letter-input');
                let answer = '';
                for (const inp of inputs) {
                  answer += inp.value.toUpperCase() || ' ';
                }
                answer = answer.trimEnd();

                // If complete (no gaps and full length), remove from list
                if (!answer.includes(' ') && answer.length === pattern.length) {
                  const clueItem = letterContainer.closest('.clue-item');
                  clueItem.style.transition = 'opacity 0.3s, transform 0.3s';
                  clueItem.style.opacity = '0';
                  clueItem.style.transform = 'translateX(-20px)';
                  setTimeout(() => {
                    clueItem.remove();
                    // Update count
                    const countEl = document.querySelector('.clue-count');
                    const remaining = document.querySelectorAll('.clue-item').length;
                    if (countEl) {
                      countEl.textContent = `${remaining} clues need answers`;
                    }
                    if (remaining === 0) {
                      document.querySelector('.clue-list').innerHTML = '<div class="empty-state">No incomplete clues found. Great job!</div>';
                    }
                  }, 300);
                }
              }
            }, 100); // Small delay to let focus settle
          });
        });
      });
    }

    function updateLetterStyle(input, idx, pattern) {
      const val = input.value;
      const patternChar = pattern[idx];

      input.classList.remove('from-pattern', 'user-entered', 'empty');

      if (val) {
        if (patternChar !== '_' && val.toUpperCase() === patternChar) {
          input.classList.add('from-pattern');
        } else {
          input.classList.add('user-entered');
        }
      } else {
        input.classList.add('empty');
      }
    }

    async function saveAnswer(letterContainer) {
      const clueId = letterContainer.dataset.clueId;
      const puzzleDate = letterContainer.dataset.puzzleDate;
      const pattern = letterContainer.dataset.pattern;
      const statusEl = document.querySelector(`[data-status-for="${clueId}"]`);
      const clueItem = letterContainer.closest('.clue-item');

      // Collect answer from all letter inputs
      const inputs = letterContainer.querySelectorAll('.letter-input');
      let answer = '';
      for (const input of inputs) {
        answer += input.value.toUpperCase() || ' ';
      }
      answer = answer.trimEnd();

      // Don't save if incomplete (has gaps)
      if (answer.includes(' ') && answer.trim().length > 0) {
        statusEl.textContent = '';
        return;
      }

      // If all empty, save empty string
      if (answer.trim().length === 0) {
        answer = '';
      }

      statusEl.textContent = 'Saving...';
      statusEl.className = 'save-status saving';

      try {
        const res = await fetch(`${API_BASE}/api/clue/${clueId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            puzzleDate,
            updates: { answer }
          })
        });

        if (!res.ok) {
          throw new Error('Failed to save');
        }

        statusEl.textContent = 'Saved';
        statusEl.className = 'save-status saved';

        // Mark as complete if answer is full length
        if (answer.length === pattern.length) {
          clueItem.classList.add('complete');
        } else {
          clueItem.classList.remove('complete');
        }

        setTimeout(() => {
          statusEl.textContent = '';
        }, 2000);
      } catch (err) {
        statusEl.textContent = 'Error';
        statusEl.className = 'save-status error';
      }
    }

    async function ignoreClue(clueId, puzzleDate) {
      try {
        const res = await fetch(`${API_BASE}/api/clue/${clueId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            puzzleDate,
            updates: { ignored: true }
          })
        });

        if (!res.ok) {
          throw new Error('Failed to ignore clue');
        }

        // Remove the clue from the list
        const clueItem = document.querySelector(`.clue-item[data-clue-id="${clueId}"][data-puzzle-date="${puzzleDate}"]`);
        if (clueItem) {
          clueItem.style.transition = 'opacity 0.3s, transform 0.3s';
          clueItem.style.opacity = '0';
          clueItem.style.transform = 'translateX(-20px)';
          setTimeout(() => {
            clueItem.remove();
            // Update count
            const countEl = document.querySelector('.clue-count');
            const remaining = document.querySelectorAll('.clue-item').length;
            if (countEl) {
              countEl.textContent = `${remaining} clues need answers`;
            }
            if (remaining === 0) {
              document.querySelector('.clue-list').innerHTML = '<div class="empty-state">No incomplete clues found. Great job!</div>';
            }
          }, 300);
        }
      } catch (err) {
        console.error('Error ignoring clue:', err);
        alert('Failed to ignore clue');
      }
    }

    function formatDate(dateStr) {
      const date = new Date(dateStr + 'T00:00:00');
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load on page ready
    loadClues();
  </script>
</body>
</html>
